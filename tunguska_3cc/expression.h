/*  3cc - Ternary C Compiler for Tunguska
 *  Copyright (C) 2008  Viktor Lofgren
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "bivalent.h"
#include "type.h"

#ifndef expression_h
#define expression_h
#include "function.h"
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <vector>
#include <stack>
#include <stdexcept>
#include <typeinfo>
using namespace std;

class word_caster;
class expression;
class function;

template <class T>
bool is_a(expression* e) { return dynamic_cast<T*>(e) != NULL; };

/* The expression system is basically a tree structure,
 * with three basic types of nodes:
 *
 *   x Bivalent branch nodes (basic arithmetic, logical relations, etc.)
 *     These all inherit the class 'bivalent'
 *
 *   x Univalent branch nodes (inversions, increments, typecasts, etc.)
 *     These all inherit the class 'univalent'
 *
 *   x Leaf nodes (constants, symbols, etc.) 
 *
 * The expression trees are generated by the parser, and traversed by invoking
 * the aproperiate eval function, which ripples through the three to carry out
 * the instruction it describes. Data is typically transfered between nodes
 * using the stack, eval6() calls for a single tryte of data, and eval12() calls
 * for two trytes of data.
 *
 * Of further importance is the cleaner class. Ideally, this should always be
 * the root node, since it makes sure that no debris is left on the stack.
 *
 */
class expression {
	public:
		expression() {
			/* Add pointer to the list of allocated expressions */
			allocated_expressions.push_back(this);	
		}
		virtual void eval6() const = 0;
		virtual void eval12() const = 0;
		virtual void autoeval() const {
			switch(typ()->size()) {
				case 0:	/* 0 isn't that far away from 1 :-P */
				case 1:
					eval6(); break;
				case 2:
					eval12(); break;
				default:
					throw new std::runtime_error("Evaluating expression of bad size");
			}
		}
		virtual const type* typ() const = 0;

		/* Used in constant folding */
		virtual bool is_const() { return false; }
		virtual int const_val() { return 0; }
		virtual void reduce() {};

		/* Used in conditionals and by the && and || operators
		 * to determine whether an operation is a truth value (e.g. a>b)
		 * or is to be turned into one using the sign operator */
		virtual bool is_logical() const { return false; }

		virtual void debug_print_tree() {
			printf("%s", typeid(*this).name());
		}

		virtual ~expression() {}

		/* Turn an array into a pointer */
		static expression* dearray(expression* a);
	protected:
		/* Delete expression if and only if it is a part of 
		 * the list of allocated expressions
		 *
		 * This is a safeguard against multiple dealloations 
		 * of the same memory (which may happen with some 
		 * bivalent expressions.) */

		static void safe_delete(expression* e) {
			std::list<expression*>::iterator i;
			for(i =  allocated_expressions.begin();
			    i != allocated_expressions.end();
			    i++) {
				if((*i) == e) {
					delete e;
					allocated_expressions.erase(i); 
					break;
				}
			}
		}
	private:
		static std::list<expression*> allocated_expressions;
};


class lvalue : public virtual expression {
public:
	virtual ~lvalue() {}
	virtual expression* refer() = 0;

	virtual lvalue* shift(int trytes, const type* t = NULL) = 0;
	virtual lvalue* struct_field(const char* field) = 0;
protected:
	virtual void assign6(expression* e) const = 0;
	virtual void assign12(expression* e) const = 0;


	virtual void post_increment6() const = 0;
	virtual void pre_increment6() const = 0;
	virtual void post_decrement6() const = 0;
	virtual void pre_decrement6() const = 0;

	virtual void post_increment12() const = 0;
	virtual void pre_increment12() const = 0;
	virtual void post_decrement12() const = 0;
	virtual void pre_decrement12() const = 0;

	friend class assigner;
	friend class pre_increment;
	friend class post_increment;
	friend class pre_decrement;
	friend class post_decrement;
};

lvalue* array_index(expression* a, expression* b);
lvalue* ptr_index(expression* a, expression* b);
lvalue* struct_ptr_field(expression* e, const char* field);

class symbol : public lvalue {
	public:
		symbol(const char* name, const type* typ = NULL, int offset = 0) {
			this->name = name;
			this->offset = offset;
			this->sym_type = typ;
		}
		virtual ~symbol() { }

		virtual void eval6() const;
		virtual void eval12() const;
		virtual int get_offset() const { return offset; }

		virtual const char* get_name() const;
		virtual const char* get_ambiguous_name() const { return name; }
		
		/* Lvalue requires these */
		virtual void assign6(expression* e) const;
		virtual void assign12(expression* e) const;
	
		virtual void post_increment6() const;
		virtual void pre_increment6() const;
		virtual void post_decrement6() const;
		virtual void pre_decrement6() const;

		virtual void post_increment12() const;
		virtual void pre_increment12() const;
		virtual void post_decrement12() const;
		virtual void pre_decrement12() const;

		virtual lvalue* struct_field(const char* field);
		virtual const type* typ() const;
		virtual expression* refer();
		virtual lvalue* shift(int trytes, const type* t = NULL);
	protected:
		symbol(const symbol& s);
		const char* name;
		int offset;
		const type* sym_type;
};

class reference : public expression {
	public:
		reference(symbol* s) {
			this->sym = s;
		}
		virtual void eval6() const;
		virtual void eval12() const;
		virtual const type* typ() const { return new t_ptr(sym->typ()); }
	private:
		symbol* sym;
};

class function_call : public expression {
	public:
		function_call(const char* name, const function_prototype& f, sllist* args);
		~function_call() {};
		virtual void eval6() const;
		virtual void eval12() const;
		virtual const type* typ() const { return fun.get_type(); }
	private:
		std::list<expression*> args;
		function_prototype fun;
		const char* name;
}; 
class constant : public expression {
	public:
		constant(int value) { 
			this->value = value;
		}

		virtual void eval6() const;
		virtual void eval12() const;
		virtual const type* typ() const { 
			if(value*value > 364*364) return new t_i12(); 
			else return new t_i6(); 
		}
		bool is_const() { return true; }
		int const_val() { return value; }
	
	private:
		int value;
};

class string_constant : public expression {
	public:
		string_constant(int offset) { 
			this->offset = offset;
		}

		virtual void eval6() const;
		virtual void eval12() const;
		virtual const type* typ() const { 
			return new t_ptr(new t_i6());	
		}
	private:
		int offset;
};


/* Specialized type for dynamic variables off the variable stack 
 *
 * This is for optimization purposes, using adders can result in
 * twice as much code -- which is REALLY bad for something as
 * frequently used as variable access */

class dynamic_variable_addr : public expression {
	public:
		dynamic_variable_addr(const char* name, const type* t, int displacement = 0) {
			this->name = name;
			this->t = t;
			this->displacement = displacement;
			
		}
		virtual ~dynamic_variable_addr() {}

		virtual void eval6() const;
		virtual void eval12() const;
		virtual const type* typ() const { return t; }
		
		bool is_const() { return false; }
		int get_offset() const {
			function* cf = function::get_current();
			symbol_table_entry* te = cf->sym_ref(name);
			if(!te) throw new runtime_error("Unable to look up symbol");

			int offset = cf->get_variables()->get_total_offset() - te->get_offset() - te->get_type()->size() + 1 + displacement;

			return offset; 
		}

		const char* get_name() const { return name; }
		int get_displacement() const { return displacement; }
	private:
		const char* name;
		const type* t;
		int displacement;
};

/* *****************************
 *
 * Interfaces
 *
 * *************************** */

class univalent : public virtual expression {
	public:
		univalent(expression* a) { 
			try {
				this->a = dearray(a); 
				reduce();
			} catch(std::invalid_argument* e) {
				delete e;
				this->a = a;
			}
		}
		virtual ~univalent() {
			expression::safe_delete(a);
		}
		virtual const type* typ() const { return a->typ(); }
		virtual void reduce() { if(a->is_const()) { a = new constant(a->const_val()); }
					else a->reduce(); }
		virtual void debug_print_tree() {
			printf("%s (", typeid(*this).name());
			a->debug_print_tree();
			printf(")");
		}
	protected:
		expression* a;
};


/* ******************************
 * 
 *    Casters
 *
 * ****************************** */

class word_caster : public univalent {
	public:
		word_caster(expression* t) : univalent(t) { typ_t = new t_i12(); }; 
		word_caster(expression* t, const type* tp) : univalent(t) { typ_t = tp; }; 
		virtual ~word_caster() {};
		virtual void eval6() const;
		virtual void eval12() const;
		virtual const type* typ() const { return typ_t; }

		virtual expression* get_base() { return a; }

		static expression* strip_pointerness(expression* e) {
			if(e->typ()->can_deref()) switch(e->typ()->size()) {
				case 1:
					return new word_caster(e, new t_i6());
				case 2:
					return new word_caster(e);
			}
			return e;
		}
	private:
		const type* typ_t;
};

class char_caster : public univalent {
	public:
		char_caster(expression* t) : univalent(t) {}; 
		virtual ~char_caster() {};
		virtual void eval6() const;
		virtual void eval12() const;
		virtual const type* typ() const { return new t_i6(); }
};

/* *****************************
 *
 * Specialized types
 *
 * **************************** */
class dereference : public lvalue, public univalent {
	public:
		dereference(expression* a, const type* t = NULL) : univalent(a) {
			if(t) Type = t;
			else Type = (a->typ())->dereference();
		}
		virtual void eval6() const;
		virtual void eval12() const;
		virtual expression* source() const { 
			if(dynamic_cast<dynamic_variable_addr*>(a)) return a;
			else return new word_caster(a, new t_ptr(Type)); 
		}; 
		virtual expression* refer() { return source(); }
		virtual const type* typ() const { return Type; }

		/* Lvalue requires these */
		virtual void assign6(expression* e) const;
		virtual void assign12(expression* e) const;
		
		virtual void post_increment6() const;
		virtual void pre_increment6() const;
		virtual void post_decrement6() const;
		virtual void pre_decrement6() const;

		virtual void post_increment12() const;
		virtual void pre_increment12() const;
		virtual void post_decrement12() const;
		virtual void pre_decrement12() const;

		virtual lvalue* struct_field(const char* field);
		virtual lvalue* shift(int trytes, const type* t = NULL);

	private:
		const type* Type;
};

/* This class is used mostly to give variable lists in functions
 * the ability to access other variables before the function has
 * been properly initialized. */
class lazy_lvalue : public expression {
public:
	lazy_lvalue(const char* name) {
		this->name = name;
		resolved_lvalue = NULL;
	}

	void eval6() const {
		if(!resolved_lvalue) reduce();
		resolved_lvalue->eval6();
	}

	void eval12() const { 
		if(!resolved_lvalue) reduce();
		resolved_lvalue->eval12();
	}

	virtual void reduce() const {
		if(!resolved_lvalue) resolved_lvalue = function::get_current()->get_symbol(name);
	}

	virtual const type* typ() const {
		try {
			reduce();
			return resolved_lvalue->typ();
		} catch(std::runtime_error* e) { // Function not yet initialized
			delete e;
			return new t_i12(); // Return some type, probably
					    // won't cause any problems
					    //  ... probably.
		}
	}

private:
	mutable expression* resolved_lvalue;
	const char* name;
};

class assigner : public univalent {
	public:
		assigner(expression* t, expression* a) : univalent(a), target(t) {
			if(dynamic_cast<lvalue*>(t) == NULL) 
				throw new runtime_error("Assigning non-lvalue");
		}
		
		virtual void eval6() const { dynamic_cast<lvalue*>(target)->assign6(a); }
		virtual void eval12() const { dynamic_cast<lvalue*>(target)->assign12(a); }
		virtual const type* typ() const { return target->typ(); }
	private:
		expression* target;
};

// Cleans up garbage on the stack

class cleaner : public univalent {
	public:
		cleaner(expression* e) : univalent(e) { e->reduce(); }
		virtual ~cleaner() { }

		virtual void eval6() const;
		virtual void eval12() const;
};

class inverter : public univalent {
	public:
		inverter(expression* a) : univalent(a) {}
		virtual void eval6() const;
		virtual void eval12() const;
		virtual bool is_const() { return a->is_const(); }
		virtual int const_val() { return - a->const_val(); }
};

class sign : public univalent {
	public:
		sign(expression* a) : univalent(a) {}
		virtual void eval6() const;
		virtual void eval12() const;
		virtual bool is_const() { return a->is_const(); }
		virtual int const_val() { 
			int cv = a->const_val();
			if(cv < 0) return -1;
			else if(cv > 0) return 1;
			else return 0;
		}

		virtual bool is_logical() const { return true; }
};

class sp_test : public univalent {
	public:
		sp_test(expression* a) : univalent(new cleaner(a)) {}
		virtual void eval6() const;
		virtual void eval12() const;
		virtual bool is_const() { return false; }
		virtual bool is_logical() const { return false; }
};


/* ++foo */
class pre_increment : public expression {
	public:
		pre_increment(expression* e) {
			lval = dynamic_cast<lvalue*>(e);
			if(!lval) throw new runtime_error("Bad lvalue");
		}
		~pre_increment() {}
		virtual void eval6() const { lval->pre_increment6(); }
		virtual void eval12() const { lval->pre_increment12(); }
		virtual const type* typ() const { return lval->typ(); }
	private:
		lvalue* lval;
};

/* foo++ */
class post_increment : public expression {
	public:
		post_increment(expression* e) {
			lval = dynamic_cast<lvalue*>(e);
			if(!lval) throw new runtime_error("Bad lvalue");
		}
		~post_increment() {}
		virtual void eval6() const { lval->post_increment6(); }
		virtual void eval12() const { lval->post_increment12(); }
		virtual const type* typ() const { return lval->typ(); }
	private:
		lvalue* lval;
};

/* --foo */
class pre_decrement : public expression {
	public:
		pre_decrement(expression* e) {
			lval = dynamic_cast<lvalue*>(e);
			if(!lval) throw new runtime_error("Bad lvalue");
		}
		~pre_decrement() {}
		virtual void eval6() const { lval->pre_decrement6(); }
		virtual void eval12() const { lval->pre_decrement12(); }
		virtual const type* typ() const { return lval->typ(); }
	private:
		lvalue* lval;
};

/* foo-- */
class post_decrement : public expression {
	public:
		post_decrement(expression* e) {
			lval = dynamic_cast<lvalue*>(e);
			if(!lval) throw new runtime_error("Bad lvalue");
		}
		~post_decrement() {}
 
		virtual void eval6() const { lval->post_decrement6(); }
		virtual void eval12() const { lval->post_decrement12(); }
		virtual const type* typ() const { return lval->typ(); }
	private:
		lvalue* lval;
};


#endif
